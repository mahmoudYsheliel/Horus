/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.30.2
 * source: hu_msgs.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARNING = 2,
    ERROR = 3,
    CRITICAL = 4
}
export enum ServiceStatus {
    OFFLINE = 0,
    ONLINE = 1
}
export enum MonitorServiceRequest {
    LOGS_HISTORY = 0,
    SERVICES_STATUS = 1,
    FILTER_CONFIG = 2,
    SETTINGS_CONFIG = 3,
    STREAM_SOURCES = 4,
    AGENTS_CONFIG = 5
}
export class LogMsg extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        timestamp?: number;
        log_level?: LogLevel;
        src?: string;
        msg?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("timestamp" in data && data.timestamp != undefined) {
                this.timestamp = data.timestamp;
            }
            if ("log_level" in data && data.log_level != undefined) {
                this.log_level = data.log_level;
            }
            if ("src" in data && data.src != undefined) {
                this.src = data.src;
            }
            if ("msg" in data && data.msg != undefined) {
                this.msg = data.msg;
            }
        }
    }
    get timestamp() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set timestamp(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get log_level() {
        return pb_1.Message.getFieldWithDefault(this, 2, LogLevel.DEBUG) as LogLevel;
    }
    set log_level(value: LogLevel) {
        pb_1.Message.setField(this, 2, value);
    }
    get src() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set src(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get msg() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set msg(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        timestamp?: number;
        log_level?: LogLevel;
        src?: string;
        msg?: string;
    }): LogMsg {
        const message = new LogMsg({});
        if (data.timestamp != null) {
            message.timestamp = data.timestamp;
        }
        if (data.log_level != null) {
            message.log_level = data.log_level;
        }
        if (data.src != null) {
            message.src = data.src;
        }
        if (data.msg != null) {
            message.msg = data.msg;
        }
        return message;
    }
    toObject() {
        const data: {
            timestamp?: number;
            log_level?: LogLevel;
            src?: string;
            msg?: string;
        } = {};
        if (this.timestamp != null) {
            data.timestamp = this.timestamp;
        }
        if (this.log_level != null) {
            data.log_level = this.log_level;
        }
        if (this.src != null) {
            data.src = this.src;
        }
        if (this.msg != null) {
            data.msg = this.msg;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.timestamp != 0)
            writer.writeUint64(1, this.timestamp);
        if (this.log_level != LogLevel.DEBUG)
            writer.writeEnum(2, this.log_level);
        if (this.src.length)
            writer.writeString(3, this.src);
        if (this.msg.length)
            writer.writeString(4, this.msg);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LogMsg {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LogMsg();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.timestamp = reader.readUint64();
                    break;
                case 2:
                    message.log_level = reader.readEnum();
                    break;
                case 3:
                    message.src = reader.readString();
                    break;
                case 4:
                    message.msg = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): LogMsg {
        return LogMsg.deserialize(bytes);
    }
}
export class LogMsgList extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        logs?: LogMsg[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("logs" in data && data.logs != undefined) {
                this.logs = data.logs;
            }
        }
    }
    get logs() {
        return pb_1.Message.getRepeatedWrapperField(this, LogMsg, 1) as LogMsg[];
    }
    set logs(value: LogMsg[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        logs?: ReturnType<typeof LogMsg.prototype.toObject>[];
    }): LogMsgList {
        const message = new LogMsgList({});
        if (data.logs != null) {
            message.logs = data.logs.map(item => LogMsg.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            logs?: ReturnType<typeof LogMsg.prototype.toObject>[];
        } = {};
        if (this.logs != null) {
            data.logs = this.logs.map((item: LogMsg) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.logs.length)
            writer.writeRepeatedMessage(1, this.logs, (item: LogMsg) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LogMsgList {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LogMsgList();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.logs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, LogMsg.deserialize(reader), LogMsg));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): LogMsgList {
        return LogMsgList.deserialize(bytes);
    }
}
export class ServicesStatusMap extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        map?: Map<string, ServiceStatus>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("map" in data && data.map != undefined) {
                this.map = data.map;
            }
        }
        if (!this.map)
            this.map = new Map();
    }
    get map() {
        return pb_1.Message.getField(this, 1) as any as Map<string, ServiceStatus>;
    }
    set map(value: Map<string, ServiceStatus>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    static fromObject(data: {
        map?: {
            [key: string]: ServiceStatus;
        };
    }): ServicesStatusMap {
        const message = new ServicesStatusMap({});
        if (typeof data.map == "object") {
            message.map = new Map(Object.entries(data.map));
        }
        return message;
    }
    toObject() {
        const data: {
            map?: {
                [key: string]: ServiceStatus;
            };
        } = {};
        if (this.map != null) {
            data.map = (Object.fromEntries)(this.map);
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.map) {
            writer.writeMessage(1, this.map, () => {
                writer.writeString(1, key);
                writer.writeEnum(2, value);
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ServicesStatusMap {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ServicesStatusMap();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.map as any, reader, reader.readString, reader.readEnum));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ServicesStatusMap {
        return ServicesStatusMap.deserialize(bytes);
    }
}
export class SingleFilterChain extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        params?: Map<string, number>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("params" in data && data.params != undefined) {
                this.params = data.params;
            }
        }
        if (!this.params)
            this.params = new Map();
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get params() {
        return pb_1.Message.getField(this, 2) as any as Map<string, number>;
    }
    set params(value: Map<string, number>) {
        pb_1.Message.setField(this, 2, value as any);
    }
    static fromObject(data: {
        name?: string;
        params?: {
            [key: string]: number;
        };
    }): SingleFilterChain {
        const message = new SingleFilterChain({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (typeof data.params == "object") {
            message.params = new Map(Object.entries(data.params));
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            params?: {
                [key: string]: number;
            };
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.params != null) {
            data.params = (Object.fromEntries)(this.params);
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.name.length)
            writer.writeString(1, this.name);
        for (const [key, value] of this.params) {
            writer.writeMessage(2, this.params, () => {
                writer.writeString(1, key);
                writer.writeFloat(2, value);
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SingleFilterChain {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SingleFilterChain();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.params as any, reader, reader.readString, reader.readFloat));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SingleFilterChain {
        return SingleFilterChain.deserialize(bytes);
    }
}
export class Filter extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        camera_name?: string;
        input_src?: string;
        output_src?: string;
        enable_recording?: boolean;
        filters_chain?: SingleFilterChain[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("camera_name" in data && data.camera_name != undefined) {
                this.camera_name = data.camera_name;
            }
            if ("input_src" in data && data.input_src != undefined) {
                this.input_src = data.input_src;
            }
            if ("output_src" in data && data.output_src != undefined) {
                this.output_src = data.output_src;
            }
            if ("enable_recording" in data && data.enable_recording != undefined) {
                this.enable_recording = data.enable_recording;
            }
            if ("filters_chain" in data && data.filters_chain != undefined) {
                this.filters_chain = data.filters_chain;
            }
        }
    }
    get camera_name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set camera_name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get input_src() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set input_src(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get output_src() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set output_src(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get enable_recording() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set enable_recording(value: boolean) {
        pb_1.Message.setField(this, 4, value);
    }
    get filters_chain() {
        return pb_1.Message.getRepeatedWrapperField(this, SingleFilterChain, 5) as SingleFilterChain[];
    }
    set filters_chain(value: SingleFilterChain[]) {
        pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    static fromObject(data: {
        camera_name?: string;
        input_src?: string;
        output_src?: string;
        enable_recording?: boolean;
        filters_chain?: ReturnType<typeof SingleFilterChain.prototype.toObject>[];
    }): Filter {
        const message = new Filter({});
        if (data.camera_name != null) {
            message.camera_name = data.camera_name;
        }
        if (data.input_src != null) {
            message.input_src = data.input_src;
        }
        if (data.output_src != null) {
            message.output_src = data.output_src;
        }
        if (data.enable_recording != null) {
            message.enable_recording = data.enable_recording;
        }
        if (data.filters_chain != null) {
            message.filters_chain = data.filters_chain.map(item => SingleFilterChain.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            camera_name?: string;
            input_src?: string;
            output_src?: string;
            enable_recording?: boolean;
            filters_chain?: ReturnType<typeof SingleFilterChain.prototype.toObject>[];
        } = {};
        if (this.camera_name != null) {
            data.camera_name = this.camera_name;
        }
        if (this.input_src != null) {
            data.input_src = this.input_src;
        }
        if (this.output_src != null) {
            data.output_src = this.output_src;
        }
        if (this.enable_recording != null) {
            data.enable_recording = this.enable_recording;
        }
        if (this.filters_chain != null) {
            data.filters_chain = this.filters_chain.map((item: SingleFilterChain) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.camera_name.length)
            writer.writeString(1, this.camera_name);
        if (this.input_src.length)
            writer.writeString(2, this.input_src);
        if (this.output_src.length)
            writer.writeString(3, this.output_src);
        if (this.enable_recording != false)
            writer.writeBool(4, this.enable_recording);
        if (this.filters_chain.length)
            writer.writeRepeatedMessage(5, this.filters_chain, (item: SingleFilterChain) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Filter {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Filter();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.camera_name = reader.readString();
                    break;
                case 2:
                    message.input_src = reader.readString();
                    break;
                case 3:
                    message.output_src = reader.readString();
                    break;
                case 4:
                    message.enable_recording = reader.readBool();
                    break;
                case 5:
                    reader.readMessage(message.filters_chain, () => pb_1.Message.addToRepeatedWrapperField(message, 5, SingleFilterChain.deserialize(reader), SingleFilterChain));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Filter {
        return Filter.deserialize(bytes);
    }
}
export class Filters extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        filters?: Map<string, Filter>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filters" in data && data.filters != undefined) {
                this.filters = data.filters;
            }
        }
        if (!this.filters)
            this.filters = new Map();
    }
    get filters() {
        return pb_1.Message.getField(this, 1) as any as Map<string, Filter>;
    }
    set filters(value: Map<string, Filter>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    static fromObject(data: {
        filters?: {
            [key: string]: ReturnType<typeof Filter.prototype.toObject>;
        };
    }): Filters {
        const message = new Filters({});
        if (typeof data.filters == "object") {
            message.filters = new Map(Object.entries(data.filters).map(([key, value]) => [key, Filter.fromObject(value)]));
        }
        return message;
    }
    toObject() {
        const data: {
            filters?: {
                [key: string]: ReturnType<typeof Filter.prototype.toObject>;
            };
        } = {};
        if (this.filters != null) {
            data.filters = (Object.fromEntries)((Array.from)(this.filters).map(([key, value]) => [key, value.toObject()]));
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.filters) {
            writer.writeMessage(1, this.filters, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Filters {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Filters();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.filters as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = Filter.deserialize(reader));
                        return value;
                    }));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Filters {
        return Filters.deserialize(bytes);
    }
}
export class ConnectionParams extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        address?: string;
        username?: string;
        password?: string;
        channel?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("address" in data && data.address != undefined) {
                this.address = data.address;
            }
            if ("username" in data && data.username != undefined) {
                this.username = data.username;
            }
            if ("password" in data && data.password != undefined) {
                this.password = data.password;
            }
            if ("channel" in data && data.channel != undefined) {
                this.channel = data.channel;
            }
        }
    }
    get address() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set address(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get username() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set username(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get password() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set password(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get channel() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set channel(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        address?: string;
        username?: string;
        password?: string;
        channel?: string;
    }): ConnectionParams {
        const message = new ConnectionParams({});
        if (data.address != null) {
            message.address = data.address;
        }
        if (data.username != null) {
            message.username = data.username;
        }
        if (data.password != null) {
            message.password = data.password;
        }
        if (data.channel != null) {
            message.channel = data.channel;
        }
        return message;
    }
    toObject() {
        const data: {
            address?: string;
            username?: string;
            password?: string;
            channel?: string;
        } = {};
        if (this.address != null) {
            data.address = this.address;
        }
        if (this.username != null) {
            data.username = this.username;
        }
        if (this.password != null) {
            data.password = this.password;
        }
        if (this.channel != null) {
            data.channel = this.channel;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.address.length)
            writer.writeString(1, this.address);
        if (this.username.length)
            writer.writeString(2, this.username);
        if (this.password.length)
            writer.writeString(3, this.password);
        if (this.channel.length)
            writer.writeString(4, this.channel);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConnectionParams {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConnectionParams();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.address = reader.readString();
                    break;
                case 2:
                    message.username = reader.readString();
                    break;
                case 3:
                    message.password = reader.readString();
                    break;
                case 4:
                    message.channel = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ConnectionParams {
        return ConnectionParams.deserialize(bytes);
    }
}
export class StreamSource extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        source_id?: string;
        source_type?: string;
        source_name?: string;
        enable_recording?: boolean;
        connection_params?: ConnectionParams;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("source_id" in data && data.source_id != undefined) {
                this.source_id = data.source_id;
            }
            if ("source_type" in data && data.source_type != undefined) {
                this.source_type = data.source_type;
            }
            if ("source_name" in data && data.source_name != undefined) {
                this.source_name = data.source_name;
            }
            if ("enable_recording" in data && data.enable_recording != undefined) {
                this.enable_recording = data.enable_recording;
            }
            if ("connection_params" in data && data.connection_params != undefined) {
                this.connection_params = data.connection_params;
            }
        }
    }
    get source_id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set source_id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get source_type() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set source_type(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get source_name() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set source_name(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get enable_recording() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set enable_recording(value: boolean) {
        pb_1.Message.setField(this, 4, value);
    }
    get connection_params() {
        return pb_1.Message.getWrapperField(this, ConnectionParams, 5) as ConnectionParams;
    }
    set connection_params(value: ConnectionParams) {
        pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_connection_params() {
        return pb_1.Message.getField(this, 5) != null;
    }
    static fromObject(data: {
        source_id?: string;
        source_type?: string;
        source_name?: string;
        enable_recording?: boolean;
        connection_params?: ReturnType<typeof ConnectionParams.prototype.toObject>;
    }): StreamSource {
        const message = new StreamSource({});
        if (data.source_id != null) {
            message.source_id = data.source_id;
        }
        if (data.source_type != null) {
            message.source_type = data.source_type;
        }
        if (data.source_name != null) {
            message.source_name = data.source_name;
        }
        if (data.enable_recording != null) {
            message.enable_recording = data.enable_recording;
        }
        if (data.connection_params != null) {
            message.connection_params = ConnectionParams.fromObject(data.connection_params);
        }
        return message;
    }
    toObject() {
        const data: {
            source_id?: string;
            source_type?: string;
            source_name?: string;
            enable_recording?: boolean;
            connection_params?: ReturnType<typeof ConnectionParams.prototype.toObject>;
        } = {};
        if (this.source_id != null) {
            data.source_id = this.source_id;
        }
        if (this.source_type != null) {
            data.source_type = this.source_type;
        }
        if (this.source_name != null) {
            data.source_name = this.source_name;
        }
        if (this.enable_recording != null) {
            data.enable_recording = this.enable_recording;
        }
        if (this.connection_params != null) {
            data.connection_params = this.connection_params.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.source_id.length)
            writer.writeString(1, this.source_id);
        if (this.source_type.length)
            writer.writeString(2, this.source_type);
        if (this.source_name.length)
            writer.writeString(3, this.source_name);
        if (this.enable_recording != false)
            writer.writeBool(4, this.enable_recording);
        if (this.has_connection_params)
            writer.writeMessage(5, this.connection_params, () => this.connection_params.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StreamSource {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StreamSource();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.source_id = reader.readString();
                    break;
                case 2:
                    message.source_type = reader.readString();
                    break;
                case 3:
                    message.source_name = reader.readString();
                    break;
                case 4:
                    message.enable_recording = reader.readBool();
                    break;
                case 5:
                    reader.readMessage(message.connection_params, () => message.connection_params = ConnectionParams.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StreamSource {
        return StreamSource.deserialize(bytes);
    }
}
export class StreamSources extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        stream_sources?: Map<string, StreamSource>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("stream_sources" in data && data.stream_sources != undefined) {
                this.stream_sources = data.stream_sources;
            }
        }
        if (!this.stream_sources)
            this.stream_sources = new Map();
    }
    get stream_sources() {
        return pb_1.Message.getField(this, 1) as any as Map<string, StreamSource>;
    }
    set stream_sources(value: Map<string, StreamSource>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    static fromObject(data: {
        stream_sources?: {
            [key: string]: ReturnType<typeof StreamSource.prototype.toObject>;
        };
    }): StreamSources {
        const message = new StreamSources({});
        if (typeof data.stream_sources == "object") {
            message.stream_sources = new Map(Object.entries(data.stream_sources).map(([key, value]) => [key, StreamSource.fromObject(value)]));
        }
        return message;
    }
    toObject() {
        const data: {
            stream_sources?: {
                [key: string]: ReturnType<typeof StreamSource.prototype.toObject>;
            };
        } = {};
        if (this.stream_sources != null) {
            data.stream_sources = (Object.fromEntries)((Array.from)(this.stream_sources).map(([key, value]) => [key, value.toObject()]));
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.stream_sources) {
            writer.writeMessage(1, this.stream_sources, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StreamSources {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StreamSources();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.stream_sources as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = StreamSource.deserialize(reader));
                        return value;
                    }));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StreamSources {
        return StreamSources.deserialize(bytes);
    }
}
export class BoundingBox extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        x?: number;
        y?: number;
        w?: number;
        h?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("x" in data && data.x != undefined) {
                this.x = data.x;
            }
            if ("y" in data && data.y != undefined) {
                this.y = data.y;
            }
            if ("w" in data && data.w != undefined) {
                this.w = data.w;
            }
            if ("h" in data && data.h != undefined) {
                this.h = data.h;
            }
        }
    }
    get x() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set x(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get y() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set y(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get w() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set w(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get h() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set h(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        x?: number;
        y?: number;
        w?: number;
        h?: number;
    }): BoundingBox {
        const message = new BoundingBox({});
        if (data.x != null) {
            message.x = data.x;
        }
        if (data.y != null) {
            message.y = data.y;
        }
        if (data.w != null) {
            message.w = data.w;
        }
        if (data.h != null) {
            message.h = data.h;
        }
        return message;
    }
    toObject() {
        const data: {
            x?: number;
            y?: number;
            w?: number;
            h?: number;
        } = {};
        if (this.x != null) {
            data.x = this.x;
        }
        if (this.y != null) {
            data.y = this.y;
        }
        if (this.w != null) {
            data.w = this.w;
        }
        if (this.h != null) {
            data.h = this.h;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.x != 0)
            writer.writeInt32(1, this.x);
        if (this.y != 0)
            writer.writeInt32(2, this.y);
        if (this.w != 0)
            writer.writeInt32(3, this.w);
        if (this.h != 0)
            writer.writeInt32(4, this.h);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BoundingBox {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BoundingBox();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.x = reader.readInt32();
                    break;
                case 2:
                    message.y = reader.readInt32();
                    break;
                case 3:
                    message.w = reader.readInt32();
                    break;
                case 4:
                    message.h = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BoundingBox {
        return BoundingBox.deserialize(bytes);
    }
}
export class DetectionData extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        class_name?: string;
        bounding_box?: BoundingBox;
        confidence?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("class_name" in data && data.class_name != undefined) {
                this.class_name = data.class_name;
            }
            if ("bounding_box" in data && data.bounding_box != undefined) {
                this.bounding_box = data.bounding_box;
            }
            if ("confidence" in data && data.confidence != undefined) {
                this.confidence = data.confidence;
            }
        }
    }
    get class_name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set class_name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get bounding_box() {
        return pb_1.Message.getWrapperField(this, BoundingBox, 2) as BoundingBox;
    }
    set bounding_box(value: BoundingBox) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_bounding_box() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get confidence() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set confidence(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        class_name?: string;
        bounding_box?: ReturnType<typeof BoundingBox.prototype.toObject>;
        confidence?: number;
    }): DetectionData {
        const message = new DetectionData({});
        if (data.class_name != null) {
            message.class_name = data.class_name;
        }
        if (data.bounding_box != null) {
            message.bounding_box = BoundingBox.fromObject(data.bounding_box);
        }
        if (data.confidence != null) {
            message.confidence = data.confidence;
        }
        return message;
    }
    toObject() {
        const data: {
            class_name?: string;
            bounding_box?: ReturnType<typeof BoundingBox.prototype.toObject>;
            confidence?: number;
        } = {};
        if (this.class_name != null) {
            data.class_name = this.class_name;
        }
        if (this.bounding_box != null) {
            data.bounding_box = this.bounding_box.toObject();
        }
        if (this.confidence != null) {
            data.confidence = this.confidence;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.class_name.length)
            writer.writeString(1, this.class_name);
        if (this.has_bounding_box)
            writer.writeMessage(2, this.bounding_box, () => this.bounding_box.serialize(writer));
        if (this.confidence != 0)
            writer.writeDouble(3, this.confidence);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DetectionData {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DetectionData();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.class_name = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.bounding_box, () => message.bounding_box = BoundingBox.deserialize(reader));
                    break;
                case 3:
                    message.confidence = reader.readDouble();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DetectionData {
        return DetectionData.deserialize(bytes);
    }
}
export class AIDetectionAgent extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        model_name?: string;
        timestamp?: number;
        source_name?: string;
        details?: DetectionData[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("model_name" in data && data.model_name != undefined) {
                this.model_name = data.model_name;
            }
            if ("timestamp" in data && data.timestamp != undefined) {
                this.timestamp = data.timestamp;
            }
            if ("source_name" in data && data.source_name != undefined) {
                this.source_name = data.source_name;
            }
            if ("details" in data && data.details != undefined) {
                this.details = data.details;
            }
        }
    }
    get model_name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set model_name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get timestamp() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set timestamp(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get source_name() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set source_name(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get details() {
        return pb_1.Message.getRepeatedWrapperField(this, DetectionData, 4) as DetectionData[];
    }
    set details(value: DetectionData[]) {
        pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    static fromObject(data: {
        model_name?: string;
        timestamp?: number;
        source_name?: string;
        details?: ReturnType<typeof DetectionData.prototype.toObject>[];
    }): AIDetectionAgent {
        const message = new AIDetectionAgent({});
        if (data.model_name != null) {
            message.model_name = data.model_name;
        }
        if (data.timestamp != null) {
            message.timestamp = data.timestamp;
        }
        if (data.source_name != null) {
            message.source_name = data.source_name;
        }
        if (data.details != null) {
            message.details = data.details.map(item => DetectionData.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            model_name?: string;
            timestamp?: number;
            source_name?: string;
            details?: ReturnType<typeof DetectionData.prototype.toObject>[];
        } = {};
        if (this.model_name != null) {
            data.model_name = this.model_name;
        }
        if (this.timestamp != null) {
            data.timestamp = this.timestamp;
        }
        if (this.source_name != null) {
            data.source_name = this.source_name;
        }
        if (this.details != null) {
            data.details = this.details.map((item: DetectionData) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.model_name.length)
            writer.writeString(1, this.model_name);
        if (this.timestamp != 0)
            writer.writeUint64(2, this.timestamp);
        if (this.source_name.length)
            writer.writeString(3, this.source_name);
        if (this.details.length)
            writer.writeRepeatedMessage(4, this.details, (item: DetectionData) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AIDetectionAgent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AIDetectionAgent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.model_name = reader.readString();
                    break;
                case 2:
                    message.timestamp = reader.readUint64();
                    break;
                case 3:
                    message.source_name = reader.readString();
                    break;
                case 4:
                    reader.readMessage(message.details, () => pb_1.Message.addToRepeatedWrapperField(message, 4, DetectionData.deserialize(reader), DetectionData));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AIDetectionAgent {
        return AIDetectionAgent.deserialize(bytes);
    }
}
export class Agent extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        path?: string;
        agent?: string;
        input_src?: string;
        agent_params?: Map<string, string>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("path" in data && data.path != undefined) {
                this.path = data.path;
            }
            if ("agent" in data && data.agent != undefined) {
                this.agent = data.agent;
            }
            if ("input_src" in data && data.input_src != undefined) {
                this.input_src = data.input_src;
            }
            if ("agent_params" in data && data.agent_params != undefined) {
                this.agent_params = data.agent_params;
            }
        }
        if (!this.agent_params)
            this.agent_params = new Map();
    }
    get path() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set path(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get agent() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set agent(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get input_src() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set input_src(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get agent_params() {
        return pb_1.Message.getField(this, 4) as any as Map<string, string>;
    }
    set agent_params(value: Map<string, string>) {
        pb_1.Message.setField(this, 4, value as any);
    }
    static fromObject(data: {
        path?: string;
        agent?: string;
        input_src?: string;
        agent_params?: {
            [key: string]: string;
        };
    }): Agent {
        const message = new Agent({});
        if (data.path != null) {
            message.path = data.path;
        }
        if (data.agent != null) {
            message.agent = data.agent;
        }
        if (data.input_src != null) {
            message.input_src = data.input_src;
        }
        if (typeof data.agent_params == "object") {
            message.agent_params = new Map(Object.entries(data.agent_params));
        }
        return message;
    }
    toObject() {
        const data: {
            path?: string;
            agent?: string;
            input_src?: string;
            agent_params?: {
                [key: string]: string;
            };
        } = {};
        if (this.path != null) {
            data.path = this.path;
        }
        if (this.agent != null) {
            data.agent = this.agent;
        }
        if (this.input_src != null) {
            data.input_src = this.input_src;
        }
        if (this.agent_params != null) {
            data.agent_params = (Object.fromEntries)(this.agent_params);
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.path.length)
            writer.writeString(1, this.path);
        if (this.agent.length)
            writer.writeString(2, this.agent);
        if (this.input_src.length)
            writer.writeString(3, this.input_src);
        for (const [key, value] of this.agent_params) {
            writer.writeMessage(4, this.agent_params, () => {
                writer.writeString(1, key);
                writer.writeString(2, value);
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Agent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Agent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.path = reader.readString();
                    break;
                case 2:
                    message.agent = reader.readString();
                    break;
                case 3:
                    message.input_src = reader.readString();
                    break;
                case 4:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.agent_params as any, reader, reader.readString, reader.readString));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Agent {
        return Agent.deserialize(bytes);
    }
}
export class Agents extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        agents?: Map<string, Agent>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("agents" in data && data.agents != undefined) {
                this.agents = data.agents;
            }
        }
        if (!this.agents)
            this.agents = new Map();
    }
    get agents() {
        return pb_1.Message.getField(this, 1) as any as Map<string, Agent>;
    }
    set agents(value: Map<string, Agent>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    static fromObject(data: {
        agents?: {
            [key: string]: ReturnType<typeof Agent.prototype.toObject>;
        };
    }): Agents {
        const message = new Agents({});
        if (typeof data.agents == "object") {
            message.agents = new Map(Object.entries(data.agents).map(([key, value]) => [key, Agent.fromObject(value)]));
        }
        return message;
    }
    toObject() {
        const data: {
            agents?: {
                [key: string]: ReturnType<typeof Agent.prototype.toObject>;
            };
        } = {};
        if (this.agents != null) {
            data.agents = (Object.fromEntries)((Array.from)(this.agents).map(([key, value]) => [key, value.toObject()]));
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.agents) {
            writer.writeMessage(1, this.agents, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Agents {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Agents();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.agents as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = Agent.deserialize(reader));
                        return value;
                    }));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Agents {
        return Agents.deserialize(bytes);
    }
}
