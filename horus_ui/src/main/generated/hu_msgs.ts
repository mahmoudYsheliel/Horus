/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.30.2
 * source: hu_msgs.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARNING = 2,
    ERROR = 3,
    CRITICAL = 4
}
export enum ServiceStatus {
    OFFLINE = 0,
    ONLINE = 1
}
export enum MonitorServiceRequest {
    LOGS_HISTORY = 0,
    SERVICES_STATUS = 1,
    FILTER_CONFIG = 2,
    SETTINGS_CONFIG = 3,
    STREAM_SOURCES = 4
}
export class LogMsg extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        timestamp?: number;
        log_level?: LogLevel;
        src?: string;
        msg?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("timestamp" in data && data.timestamp != undefined) {
                this.timestamp = data.timestamp;
            }
            if ("log_level" in data && data.log_level != undefined) {
                this.log_level = data.log_level;
            }
            if ("src" in data && data.src != undefined) {
                this.src = data.src;
            }
            if ("msg" in data && data.msg != undefined) {
                this.msg = data.msg;
            }
        }
    }
    get timestamp() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set timestamp(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get log_level() {
        return pb_1.Message.getFieldWithDefault(this, 2, LogLevel.DEBUG) as LogLevel;
    }
    set log_level(value: LogLevel) {
        pb_1.Message.setField(this, 2, value);
    }
    get src() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set src(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get msg() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set msg(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        timestamp?: number;
        log_level?: LogLevel;
        src?: string;
        msg?: string;
    }): LogMsg {
        const message = new LogMsg({});
        if (data.timestamp != null) {
            message.timestamp = data.timestamp;
        }
        if (data.log_level != null) {
            message.log_level = data.log_level;
        }
        if (data.src != null) {
            message.src = data.src;
        }
        if (data.msg != null) {
            message.msg = data.msg;
        }
        return message;
    }
    toObject() {
        const data: {
            timestamp?: number;
            log_level?: LogLevel;
            src?: string;
            msg?: string;
        } = {};
        if (this.timestamp != null) {
            data.timestamp = this.timestamp;
        }
        if (this.log_level != null) {
            data.log_level = this.log_level;
        }
        if (this.src != null) {
            data.src = this.src;
        }
        if (this.msg != null) {
            data.msg = this.msg;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.timestamp != 0)
            writer.writeUint64(1, this.timestamp);
        if (this.log_level != LogLevel.DEBUG)
            writer.writeEnum(2, this.log_level);
        if (this.src.length)
            writer.writeString(3, this.src);
        if (this.msg.length)
            writer.writeString(4, this.msg);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LogMsg {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LogMsg();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.timestamp = reader.readUint64();
                    break;
                case 2:
                    message.log_level = reader.readEnum();
                    break;
                case 3:
                    message.src = reader.readString();
                    break;
                case 4:
                    message.msg = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): LogMsg {
        return LogMsg.deserialize(bytes);
    }
}
export class LogMsgList extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        logs?: LogMsg[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("logs" in data && data.logs != undefined) {
                this.logs = data.logs;
            }
        }
    }
    get logs() {
        return pb_1.Message.getRepeatedWrapperField(this, LogMsg, 1) as LogMsg[];
    }
    set logs(value: LogMsg[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        logs?: ReturnType<typeof LogMsg.prototype.toObject>[];
    }): LogMsgList {
        const message = new LogMsgList({});
        if (data.logs != null) {
            message.logs = data.logs.map(item => LogMsg.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            logs?: ReturnType<typeof LogMsg.prototype.toObject>[];
        } = {};
        if (this.logs != null) {
            data.logs = this.logs.map((item: LogMsg) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.logs.length)
            writer.writeRepeatedMessage(1, this.logs, (item: LogMsg) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LogMsgList {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LogMsgList();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.logs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, LogMsg.deserialize(reader), LogMsg));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): LogMsgList {
        return LogMsgList.deserialize(bytes);
    }
}
export class ServicesStatusMap extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        map?: Map<string, ServiceStatus>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("map" in data && data.map != undefined) {
                this.map = data.map;
            }
        }
        if (!this.map)
            this.map = new Map();
    }
    get map() {
        return pb_1.Message.getField(this, 1) as any as Map<string, ServiceStatus>;
    }
    set map(value: Map<string, ServiceStatus>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    static fromObject(data: {
        map?: {
            [key: string]: ServiceStatus;
        };
    }): ServicesStatusMap {
        const message = new ServicesStatusMap({});
        if (typeof data.map == "object") {
            message.map = new Map(Object.entries(data.map));
        }
        return message;
    }
    toObject() {
        const data: {
            map?: {
                [key: string]: ServiceStatus;
            };
        } = {};
        if (this.map != null) {
            data.map = (Object.fromEntries)(this.map);
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.map) {
            writer.writeMessage(1, this.map, () => {
                writer.writeString(1, key);
                writer.writeEnum(2, value);
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ServicesStatusMap {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ServicesStatusMap();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.map as any, reader, reader.readString, reader.readEnum));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ServicesStatusMap {
        return ServicesStatusMap.deserialize(bytes);
    }
}
export class Filter extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        filter?: string;
        input_src?: string;
        output_channel?: string;
        enable_recording?: boolean;
        filter_params?: Map<string, number>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filter" in data && data.filter != undefined) {
                this.filter = data.filter;
            }
            if ("input_src" in data && data.input_src != undefined) {
                this.input_src = data.input_src;
            }
            if ("output_channel" in data && data.output_channel != undefined) {
                this.output_channel = data.output_channel;
            }
            if ("enable_recording" in data && data.enable_recording != undefined) {
                this.enable_recording = data.enable_recording;
            }
            if ("filter_params" in data && data.filter_params != undefined) {
                this.filter_params = data.filter_params;
            }
        }
        if (!this.filter_params)
            this.filter_params = new Map();
    }
    get filter() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set filter(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get input_src() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set input_src(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get output_channel() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set output_channel(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get enable_recording() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set enable_recording(value: boolean) {
        pb_1.Message.setField(this, 4, value);
    }
    get filter_params() {
        return pb_1.Message.getField(this, 5) as any as Map<string, number>;
    }
    set filter_params(value: Map<string, number>) {
        pb_1.Message.setField(this, 5, value as any);
    }
    static fromObject(data: {
        filter?: string;
        input_src?: string;
        output_channel?: string;
        enable_recording?: boolean;
        filter_params?: {
            [key: string]: number;
        };
    }): Filter {
        const message = new Filter({});
        if (data.filter != null) {
            message.filter = data.filter;
        }
        if (data.input_src != null) {
            message.input_src = data.input_src;
        }
        if (data.output_channel != null) {
            message.output_channel = data.output_channel;
        }
        if (data.enable_recording != null) {
            message.enable_recording = data.enable_recording;
        }
        if (typeof data.filter_params == "object") {
            message.filter_params = new Map(Object.entries(data.filter_params));
        }
        return message;
    }
    toObject() {
        const data: {
            filter?: string;
            input_src?: string;
            output_channel?: string;
            enable_recording?: boolean;
            filter_params?: {
                [key: string]: number;
            };
        } = {};
        if (this.filter != null) {
            data.filter = this.filter;
        }
        if (this.input_src != null) {
            data.input_src = this.input_src;
        }
        if (this.output_channel != null) {
            data.output_channel = this.output_channel;
        }
        if (this.enable_recording != null) {
            data.enable_recording = this.enable_recording;
        }
        if (this.filter_params != null) {
            data.filter_params = (Object.fromEntries)(this.filter_params);
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.filter.length)
            writer.writeString(1, this.filter);
        if (this.input_src.length)
            writer.writeString(2, this.input_src);
        if (this.output_channel.length)
            writer.writeString(3, this.output_channel);
        if (this.enable_recording != false)
            writer.writeBool(4, this.enable_recording);
        for (const [key, value] of this.filter_params) {
            writer.writeMessage(5, this.filter_params, () => {
                writer.writeString(1, key);
                writer.writeFloat(2, value);
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Filter {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Filter();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.filter = reader.readString();
                    break;
                case 2:
                    message.input_src = reader.readString();
                    break;
                case 3:
                    message.output_channel = reader.readString();
                    break;
                case 4:
                    message.enable_recording = reader.readBool();
                    break;
                case 5:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.filter_params as any, reader, reader.readString, reader.readFloat));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Filter {
        return Filter.deserialize(bytes);
    }
}
export class Filters extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        filters?: Map<string, Filter>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filters" in data && data.filters != undefined) {
                this.filters = data.filters;
            }
        }
        if (!this.filters)
            this.filters = new Map();
    }
    get filters() {
        return pb_1.Message.getField(this, 1) as any as Map<string, Filter>;
    }
    set filters(value: Map<string, Filter>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    static fromObject(data: {
        filters?: {
            [key: string]: ReturnType<typeof Filter.prototype.toObject>;
        };
    }): Filters {
        const message = new Filters({});
        if (typeof data.filters == "object") {
            message.filters = new Map(Object.entries(data.filters).map(([key, value]) => [key, Filter.fromObject(value)]));
        }
        return message;
    }
    toObject() {
        const data: {
            filters?: {
                [key: string]: ReturnType<typeof Filter.prototype.toObject>;
            };
        } = {};
        if (this.filters != null) {
            data.filters = (Object.fromEntries)((Array.from)(this.filters).map(([key, value]) => [key, value.toObject()]));
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.filters) {
            writer.writeMessage(1, this.filters, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Filters {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Filters();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.filters as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = Filter.deserialize(reader));
                        return value;
                    }));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Filters {
        return Filters.deserialize(bytes);
    }
}
export class ConnectionParams extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        address?: string;
        username?: string;
        password?: string;
        channel?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("address" in data && data.address != undefined) {
                this.address = data.address;
            }
            if ("username" in data && data.username != undefined) {
                this.username = data.username;
            }
            if ("password" in data && data.password != undefined) {
                this.password = data.password;
            }
            if ("channel" in data && data.channel != undefined) {
                this.channel = data.channel;
            }
        }
    }
    get address() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set address(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get username() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set username(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get password() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set password(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get channel() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set channel(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        address?: string;
        username?: string;
        password?: string;
        channel?: string;
    }): ConnectionParams {
        const message = new ConnectionParams({});
        if (data.address != null) {
            message.address = data.address;
        }
        if (data.username != null) {
            message.username = data.username;
        }
        if (data.password != null) {
            message.password = data.password;
        }
        if (data.channel != null) {
            message.channel = data.channel;
        }
        return message;
    }
    toObject() {
        const data: {
            address?: string;
            username?: string;
            password?: string;
            channel?: string;
        } = {};
        if (this.address != null) {
            data.address = this.address;
        }
        if (this.username != null) {
            data.username = this.username;
        }
        if (this.password != null) {
            data.password = this.password;
        }
        if (this.channel != null) {
            data.channel = this.channel;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.address.length)
            writer.writeString(1, this.address);
        if (this.username.length)
            writer.writeString(2, this.username);
        if (this.password.length)
            writer.writeString(3, this.password);
        if (this.channel.length)
            writer.writeString(4, this.channel);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConnectionParams {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConnectionParams();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.address = reader.readString();
                    break;
                case 2:
                    message.username = reader.readString();
                    break;
                case 3:
                    message.password = reader.readString();
                    break;
                case 4:
                    message.channel = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ConnectionParams {
        return ConnectionParams.deserialize(bytes);
    }
}
export class StreamSource extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        source_id?: string;
        source_type?: string;
        source_name?: string;
        enable_recording?: boolean;
        connection_params?: ConnectionParams;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("source_id" in data && data.source_id != undefined) {
                this.source_id = data.source_id;
            }
            if ("source_type" in data && data.source_type != undefined) {
                this.source_type = data.source_type;
            }
            if ("source_name" in data && data.source_name != undefined) {
                this.source_name = data.source_name;
            }
            if ("enable_recording" in data && data.enable_recording != undefined) {
                this.enable_recording = data.enable_recording;
            }
            if ("connection_params" in data && data.connection_params != undefined) {
                this.connection_params = data.connection_params;
            }
        }
    }
    get source_id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set source_id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get source_type() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set source_type(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get source_name() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set source_name(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get enable_recording() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set enable_recording(value: boolean) {
        pb_1.Message.setField(this, 4, value);
    }
    get connection_params() {
        return pb_1.Message.getWrapperField(this, ConnectionParams, 5) as ConnectionParams;
    }
    set connection_params(value: ConnectionParams) {
        pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_connection_params() {
        return pb_1.Message.getField(this, 5) != null;
    }
    static fromObject(data: {
        source_id?: string;
        source_type?: string;
        source_name?: string;
        enable_recording?: boolean;
        connection_params?: ReturnType<typeof ConnectionParams.prototype.toObject>;
    }): StreamSource {
        const message = new StreamSource({});
        if (data.source_id != null) {
            message.source_id = data.source_id;
        }
        if (data.source_type != null) {
            message.source_type = data.source_type;
        }
        if (data.source_name != null) {
            message.source_name = data.source_name;
        }
        if (data.enable_recording != null) {
            message.enable_recording = data.enable_recording;
        }
        if (data.connection_params != null) {
            message.connection_params = ConnectionParams.fromObject(data.connection_params);
        }
        return message;
    }
    toObject() {
        const data: {
            source_id?: string;
            source_type?: string;
            source_name?: string;
            enable_recording?: boolean;
            connection_params?: ReturnType<typeof ConnectionParams.prototype.toObject>;
        } = {};
        if (this.source_id != null) {
            data.source_id = this.source_id;
        }
        if (this.source_type != null) {
            data.source_type = this.source_type;
        }
        if (this.source_name != null) {
            data.source_name = this.source_name;
        }
        if (this.enable_recording != null) {
            data.enable_recording = this.enable_recording;
        }
        if (this.connection_params != null) {
            data.connection_params = this.connection_params.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.source_id.length)
            writer.writeString(1, this.source_id);
        if (this.source_type.length)
            writer.writeString(2, this.source_type);
        if (this.source_name.length)
            writer.writeString(3, this.source_name);
        if (this.enable_recording != false)
            writer.writeBool(4, this.enable_recording);
        if (this.has_connection_params)
            writer.writeMessage(5, this.connection_params, () => this.connection_params.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StreamSource {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StreamSource();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.source_id = reader.readString();
                    break;
                case 2:
                    message.source_type = reader.readString();
                    break;
                case 3:
                    message.source_name = reader.readString();
                    break;
                case 4:
                    message.enable_recording = reader.readBool();
                    break;
                case 5:
                    reader.readMessage(message.connection_params, () => message.connection_params = ConnectionParams.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StreamSource {
        return StreamSource.deserialize(bytes);
    }
}
export class StreamSources extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        stream_sources?: Map<string, StreamSource>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("stream_sources" in data && data.stream_sources != undefined) {
                this.stream_sources = data.stream_sources;
            }
        }
        if (!this.stream_sources)
            this.stream_sources = new Map();
    }
    get stream_sources() {
        return pb_1.Message.getField(this, 1) as any as Map<string, StreamSource>;
    }
    set stream_sources(value: Map<string, StreamSource>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    static fromObject(data: {
        stream_sources?: {
            [key: string]: ReturnType<typeof StreamSource.prototype.toObject>;
        };
    }): StreamSources {
        const message = new StreamSources({});
        if (typeof data.stream_sources == "object") {
            message.stream_sources = new Map(Object.entries(data.stream_sources).map(([key, value]) => [key, StreamSource.fromObject(value)]));
        }
        return message;
    }
    toObject() {
        const data: {
            stream_sources?: {
                [key: string]: ReturnType<typeof StreamSource.prototype.toObject>;
            };
        } = {};
        if (this.stream_sources != null) {
            data.stream_sources = (Object.fromEntries)((Array.from)(this.stream_sources).map(([key, value]) => [key, value.toObject()]));
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.stream_sources) {
            writer.writeMessage(1, this.stream_sources, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StreamSources {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StreamSources();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.stream_sources as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = StreamSource.deserialize(reader));
                        return value;
                    }));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StreamSources {
        return StreamSources.deserialize(bytes);
    }
}
